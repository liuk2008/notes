
1、Activity、Fragment嵌套使用
2、路由框架、模块化、组件化
3、Gradle插件
4、插件化开发
5、热修复实现原理
6、APP进程间通讯
7、后台服务保活机制

===============================================================

1、数据库：索引、事务、视图、SQL注入
2、网络通信：HTTP协议、TCP/IP协议
3、接口自动化测试
4、数据结构
	数组、栈、队列（单端队列、双端队列）、链表（单向链表、双向链表）
	二叉树、散列表、图、堆
5、设计模式
	单例模式、工厂模式、Builder模式、代理模式、观察者模式、适配器模式

===============================================================

模块化：模块指的是独立的业务模块，比如首页模块。在划分的时候，模块化是业务导向，组件化是功能导向。
组件化：组件指的是单一的功能组件，如支付组件，每个组件都可以以一个单独的module开发，并且可以单独抽出来作为SDK对外发布使用。

框架组件化
    1、基础功能组件：
	1、网络框架：Retrofit2、HttpURLConnection
	2、数据库框架：SQLite
	3、公共组件：工具类、获取图库、申请权限
	4、View组件：WebView框架、RefreshView
	5、注解组件：ViewInject框架、Gradle插件
    2、第三方组件：
	1、扫码组件
	2、分享组件
	3、推送组件
    3、基础业务组件：
	1、BaseFragment
	2、BaseActivity
    4、核心管理组件：
	1、路由框架
	2、Gradle插件
    注意事项：
	1、组件初始化管理
	2、组件之间相互独立
	3、统一规范Gradle配置、ProGuard规则
	4、注意第三方库版本冲突，必要时统一管理第三方库
	5、数据需要全局共享时，考虑下沉到底层组件统一管理
	6、注意不同组件同名资源文件冲突
	7、注意AndroidManifest.xml合并

业务模块化
    1、模块之间的跳转（路由框架）
    2、模块之间的通信（EventBus、Broadcast）
    3、模块之间的服务调用？
    常见问题：
	1、模块是否需要独立编译？
	2、模块之间的耦合性？
	3、原生与H5页面之间的交互

辅助工具
    1、搭建Jenkins持续集成平台，构建APP自动化打包
    2、依托bintray平台搭建maven仓库，下发APP基础组件
    3、编写Python脚本，搭建Python+Requests接口自动化测试框架

===============================================================

APT工具
    在编译期间读取Java代码，解析注解，动态生成指定的Java代码，最后通过反射调用实现相应的功能

    执行顺序：
	定义注解-->编写注解处理器-->扫描注解-->处理注解-->生成代理类-->反射调用代理类

    具体步骤：
    	1、定义注解：在源文件中使用
	2、定义接口
		1、Finder接口，实现查找控件id功能
		2、ViewInjector接口，定义inject方法，注入代码
    	3、编写注解处理器：
		1、扫描源代码文件中指定的Annotation
    		2、处理注解：按照指定的规则对扫描到的Annotation进行处理
		3、生成指定的源文件：使用JavaPoet生成Java文件，生成代理类，实现ViewInjector接口
	4、初始化ViewInject控件
		1、通过反射获取系统R文件中关于id的Class对象，同时创建ViewFinder对象
	 	2、通过反射调用生成的代理类，入参Class对象和ViewFinder对象


Gradle插件
    由class转换成dex文件之前的编译过程中，加入开发者自定义的处理逻辑操作，它是一种获取class的方式，在代码编译之后，生成dex之前起作用。
    基于Javassist实现动态代理：修改目标类的字节，在程序编译的时候插入动态代理的字节码，不会生成全新的Class

    执行顺序：
 	编写插件--> 注册Transform-->引用插件-->扫描class文件-->生成自定义class文件

    具体步骤：
	1、编写Transfrom
	2、
