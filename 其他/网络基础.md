
## HTTP协议 ##

**HTTP建立连接**

* 1、域名解析，请求DNS服务来获取对应的ip，查询流程：浏览器DNS缓存地址-->系统DNS缓存地址-->hosts文件中的映射表-->DNS域名服务器
* DNS服务器发送查询请求的时候，先从根服务器获对应顶级域名的ip，然后再逐级从定义域名ip向下查找各个下属域服务的，找到完整的域名ip。
* 2、获取ip后，发起TCP三次握手建立连接
* 3、建立连接后发起http请求
* 4、服务器响应请求，浏览器获取html源码
* 5、浏览器解析html代码，并请求相关css、js和图片资源
* 6、浏览器渲染页面

**HTTPS加密过程**

* 1、客户端发送请求到服务端，发送客户端支持的加密协议以及版本（SSL、TLS）
* 2、服务端选择合适的协议，生成公钥和私钥，返回一个包含公钥的证书到客户端
* 3、客户端接收后会验证证书的安全性，如果通过则会随机生成一个随机数（对称加密密钥），用公钥对其加密，发送到服务端
* 4、服务端接受后会用私钥对其解密得到真正的随机数（对称加密密钥），随后用这个随机数当做私钥对需要发送的数据进行对称加密
* 5、客户端在接收到加密后的数据使用对称加密密钥(即生成的随机值)对数据进行解密并且解析数据呈现结果给客户
* 6、SSL加密建立
* 注意：
	* 1、http传输数据至少存在着数据被监听以及数据被篡改这两大风险
	* 2、为什么要先用非对称加密建立连接呢？为了安全传输创建的对称加密秘钥
	* 3、通过非对称加密传输对称加密秘钥，服务端收到客户端生成的密钥之后，后续的传输都使用对称加密来进行通信了
	* 4、为什么要使用CA证书？保证客户端安全的接收服务端发送的公钥，防止被公钥被篡改
	* 5、CA证书如何保证安全性？在制作证书中加入网站的域名，防止CA证书被替换后可以解密数据，CA证书中包含的域名必须和浏览器正在请求的域名一致
	
**CA认证**

* CA机构专门用于给各个网站签发数字证书，从而保证浏览器可以安全地获得各个网站的公钥
* 1、将自己的公钥提交给CA机构，CA机构则会使用我们提交的公钥，再加上一系列其他的信息，如网站域名、有效时长等，来制作证书
* 2、CA机构会使用自己的私钥对证书加密，并将加密后的数据返回给我们，我们只需要将获得的加密数据配置到网站服务器上即可
* 3、每当有浏览器请求我们的网站时，首先会将这段加密数据返回给浏览器，此时浏览器会用CA机构的公钥来对这段数据解密得到CA证书。如果无法解密成功，则说明此段加密数据并不是由一个合法的CA机构使用私钥加密而来的，有可能是被篡改了，于是会在浏览器上显示一个著名的异常界面
* 4、操作系统会将所有主流CA机构的公钥内置到操作系统当中，所以我们不用额外获取，解密时只需遍历系统中所有内置的CA机构的公钥，只要有任何一个公钥能够正常解密出数据，就说明它是合法的
	
**HTTP内容编码**

* 在http协议中，可以对内容（也就是body部分）进行编码
	* 1、可以采用压缩编码，比如gzip这样的从而达到压缩的目的，因此http压缩就是HTTP内容编码的一种
	* 2、可以使用其他的编码把内容搅乱或加密，以此来防止未授权的第三方看到文档的内容
       
**HTTP压缩**

采用通用的压缩算法，比如gzip来压缩HTML,Javascript, CSS文件，能大大减少网络传输的数据量，提高了用户显示网页的速度

* 1、压缩过程：
	* 1、发送request包含Accept-Encoding: gzip, deflate。(告诉服务器， 浏览器支持gzip压缩)
	* 2、Web服务器接到request后，生成原始的response, 其中有原始的Content-Type和Content-Length
	* 3、Web服务器通过Gzip来对Response进行编码，编码后header中有Content-Type和Content-Length(压缩后的大小)，并且增加了Content-Encoding:gzip
	* 4、将response发送给浏览器，然后根据Content-Encoding:gzip来对response进行解码，获取到原始response后显示出网页 
* 2、Content-Encoding值
	* gzip：表明实体采用GNU zip编码，PEG这类文件用gzip压缩的不够好。简单来说，Gzip压缩是在一个文本文件中找出类似的字符串，并临时替换他们，使整个文件变小。这种形式的压缩对Web来说非常适合， 因为HTML和CSS文件通常包含大量的重复的字符串，例如空格，标签
	* compress：表明实体采用Unix的文件压缩程序
	* deflate：表明实体是用zlib的格式压缩的
	* identity：表明没有对实体进行编码。当没有Content-Encoding header时，就默认为这种情况
	* gzip, compress, 以及deflate编码都是无损压缩算法，用于减少传输报文的大小，不会导致信息损失，其中gzip通常效率最高， 使用最为广泛。

**HTTP请求头**

* request的Cache-control和response Cache-control不同点
	* request：设置Cache-Control是no-cache，是不读取客户端缓存数据，直接请求最新数据
	* response：设置Cache-Control是max-age=xxx 是通知客户端缓存数据
* maxAge和maxStale的区别在于：
	* maxAge:没有超出maxAge,不管怎么样都是返回缓存数据，超过了maxAge，发起新的请求获取数据更新，请求失败返回缓存数据。
	* maxStale:没有超过maxStale，不管怎么样都返回缓存数据，超过了maxStale，发起请求获取更新数据，请求失败返回失败。

**长链接和短连接**
    
* HTTP分为长连接和短连接其实本质上是说的TCP连接。TCP连接是一个双向的通道，它是可以保持一段时间不关闭的，因此TCP连接才有真正的长连接和短连接这一说。
* HTTP长连接是指的TCP连接，也就是说复用的是TCP连接，多个HTTP请求可以复用同一个TCP连接，这就节省了很多TCP连接建立和断开的消耗，如果一段时间内（具体的时间长短，是可以在header当中进行设置的，也就是所谓的超时时间），这个连接没有HTTP请求发出的话，那么这个长连接就会被断掉
    * 1、Connection: Keep-alive，表示复用底层TCP链接
    * 2、Keep-Alive: timeout=20，表示这个TCP通道可以保持20秒。另外还可能有max=XXX，表示这个长连接最多接收XXX次请求就断开
    * 3、TCP的Keep-alive是检查当前TCP连接是否活着，HTTP的Keep-Alive是要让一个TCP连接活久点。它们是不同层次的概念。
 

## TCP/IP协议 ##

**三次挥手(建立连接)**

* 第一次：建立连接时，客户端发送SYN包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；
* 第二次：服务器收到SYN包，向客户端返回ACK（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RCVD状态；
* 第三次：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。
* 完成三次握手，客户端与服务器开始传送数据，也就是ESTABLISHED状态。
* 三次握手保证了不会建立无效的连接，从而浪费资源。

**四次挥手(断开连接)**

* 第一次： TCP客户端发送一个FIN(fin=m)，用来关闭客户到服务器的数据传送。
* 第二次：服务器收到这个FIN，它发回一个ACK(ack=m+1)，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
* 第三次：服务器关闭客户端的连接，发送一个FIN( fin=n)给客户端。
* 第四次：客户端发回ACK(ack=n+1)报文确认，并将确认序号设置为收到序号加1。


## 网络模型 ##

**OSI模型**

* 应用层（HTTP、SMTP）  表示层（Telnet）  会话层（DNS）  传输层（TCP、UDP）  网络层（IP）  数据链路层  物理层
	* 应用层：为用户提供常用的应用程序，每个网络应用都对应着不同的协议
	* 表示层：主要作用之一是为异种机通信提供一种公共语言，确保一个系统的应用层发送的消息可以被另一个系统的应用层读取
	* 会话层：负责网络中两节点的建立，在数据传输中维护计算机网络中两台计算机之间的通信连接，并决定何时终止通信
	* 数据链路层：物理地址（MAC地址），网络设备的唯一身份标识
	* 物理层：主要是物理介质传输媒介（网线或者是无线）

**TCP/IP模型**

* 应用层（HTTP、SMTP）  传输层（TCP、UDP）  网络层（IP）  物理层


## Nginx代理 ##

**正向代理**

* 正向代理的是客户端，是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器）

**反向代理**

* 反向代理的是服务端，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息

**负载均衡**

* 客户端发送的、Nginx反向代理服务器接收到的请求数量，就是所谓的负载量。请求数量按照一定的规则进行分发，到不同的服务器处理的规则，就是一种均衡规则。所以将服务器接收到的请求按照规则分发的过程，称为负载均衡。


## 加密规则 ##

**对称加密与非对称加密**

* 对称加密即加密的密钥和解密的密钥相同（以DES算法为代表）
* 非对称加密将密钥分为公钥和私钥，公钥可以公开，私钥需要保密，客户端公钥加密的数据，服务端可以通过私钥来解密（以RSA算法为代表）
* 在正式的使用场景中一般都是对称加密和非对称加密结合使用，使用非对称加密完成秘钥的传递，然后使用对称秘钥进行数据加密和解密

**公钥、私钥关系**

* 1、一个公钥对应一个私钥。
* 2、密钥对中，让大家都知道的是公钥，不告诉大家，只有自己知道的，是私钥。
* 3、如果用其中一个密钥加密数据，则只有对应的那个密钥才可以解密。		
* 4、如果用其中一个密钥可以进行解密数据，则该数据必然是对应的那个密钥进行的加密。
* 5、非对称密钥密码的主要应用就是公钥加密和公钥认证，而公钥加密的过程和公钥认证的过程是不一样的

**数字签名**
* 公钥：公钥用于加密信息和解密数字签名
* 私钥：私钥用于解密信息和加密消息摘要
* 消息摘要，数字指纹：对消息使用HASH算法获取的固定长度的字符串
* 数字签名：使用私钥加密的消息摘要
* 数字证书：CA用自己的私钥，对需要认证的公钥及相关的信息进行加密
* 甲使用自己的私钥对消息摘要进行加密，连同乙的公钥加密的正文一起发送给乙；乙使用甲的公钥解密消息摘要，使用自己的私钥解密得到正文，再运算出正文的摘要，将这两个摘要进行对比，如果这两个摘要相同说明这个正文没有被篡改过。
这个使用私钥加密的消息摘要就是数字签名。

**base64编解码**

* 一种用64个字符来表示任意二进制数据的方法
* 1、base64编码后的数据是一个字符串，其包括a-z、A-Z、0-9、/、+共64个字符，对应数值为0-63，2^6=64
* 2、每个6个bit为一组，4 * 6=24bit，4个为一个单元--->对应3个Byte，3 * 8=24bit，所以每3个字节一组
* 3、数据字节数不是3的倍数时需，Base64用 \x00　在原数据后添加1个或2个零值字节，使其字节数为3的倍数，然后在编码后的字符串后添加1个或2个‘=’，表示零值字节
* 4、Base64编码后可能出现字符+和/，在URL中就不能直接作为参数，URL中就是把字符+和/分别变成-和_


**摘要算法**

* 又称哈希算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）
* 1、MD5是最常见的摘要算法，速度很快，生成结果是固定的128bit，通常用一个32位的16进制字符串表示
* 2、SHA1的结果是160bit，通常用一个40位的16进制字符串表示
* 3、原始数据加一个复杂字符串用md5加密，俗称“md5加盐”
