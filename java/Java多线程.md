## Java多线程 ##

**进程&&线程概念**
	
 	* 进程：进程就是正在运行的程序，是系统进行资源分配和调用的独立单位。每一个进程都有它自己的内存空间和系统资源。
 	* 多进程有什么意义呢?
		* 多进程的作用不是提高执行速度，而是提高CPU的使用率。
 		* 单核计算机：CPU多个进程间进行高效的切换，在任意一个时刻，只能有一个进程运行。

	* 线程： 线程是指进程中的一个执行流程，一个进程可以运行多个线程。线程是程序中单个顺序的控制流，是程序使用CPU的基本单位。
	* 线程是一个操作系统级别的概念。JAVA语言（包括其他编程语言）本身不创建线程；而是调用操作系统层提供的接口创建、控制、销毁线程实例。
	* 多线程有什么意义呢?
 	 	* 多线程的作用不是提高执行速度，而是为了提高应用程序的使用率。 
 	 	* 因为多个线程共享同一个进程的资源(堆内存和方法区)，但是栈内存是独立的，一个线程一个栈。
 	 	* 所以他们仍然是在抢CPU的资源执行。一个时间点上只有能有一个线程执行。

	* 注意：
		* 1、一个进程中的多个线程来说，共享进程的内存块，当有新的线程产生的时候，操作系统不分配新的内存，而是让新线程共享原有的进程块的内存。
		* 因此，线程间的通信很容易，速度也很快。不同的进程因为处于不同的内存块，因此进程之间的通信相对困难。
		* 2、进程主要是针对是在内存管理的虚拟对象，线程主要是针对CPU管理的虚拟对象

	* 进程&线程运行机制：
		* 1、JVM在操作系统中是作为一个进程的，Java所有的线程都运行自这个JVM进程中
		* 2、OS负责将一个进程在不同的CPU上调度到另外一个CPU上，而这个进程，则是由不同的线程构成的，那么说，线程可以在不同的CPU上运行
		* 3、OS将线程作为最小调度单位，进程作为资源分配的最小单位。线程也是由内核来管理的，所以说多线程可以同时运行在多个CPU核上，
		* 但是这也带来一个问题就是，线程切换需要内核的参与。
	
	* JVM运行机制：
		* Java中线程会按优先级分配CPU时间片运行，JVM调度的模式有两种：分时调度和抢占式调度。底层，实际是通过操作系统调度。
			* 1、分时调度 是所有线程轮流获得CPU使用权，并平均分配每个线程占用CPU的时间;
			* 2、抢占式调度 是根据线程的优先级别来获取CPU的使用权。

	* JVM创建线程：底层实际通过不同的操作系统进行创建。实现线程主要有三种方式：使用内核线程实现，使用用户线程实现和使用用户线程加轻量级进程混合实现。
		* 内核线程：直接由操作系统内核支持的线程。由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。
		* 用户线程：由应用进程利用线程库创建和管理，不依赖操作系统的核心，不需要用户态/内核态的切换，速度快，操作系统内核不知道
		* 用户线程加轻量级进程混合实现：

**1、线程生命周期**


**2、FutureTask&&Callable**

	* 1、通过实现 Callable 接口，创建线程任务，可以返回任务执行结果。
	* 2、调用 FutureTask 类，传递 Callable 任务，开启工作线程执行任务
		 * Callable：call()运行在工作线程
	* 3、在 FutureTask 类中，线程执行完毕以及取消任务后，done()方法会被调用。
		 * 任务正常结束后，done()运行在工作线程
		 * 任务取消后，done()运行在当前线程
	* 4、在当前线程中调用 FutureTask 类的 get() 获取任务执行完毕后的结果，但是会阻塞当前线程
	
	* 注意：
		* 1、可以在done()方法中调用get()获取到任务执行结果，且不会阻塞当前线程
		* 2、调用 FutureTask 类 cancel() 方法后，会抛出 CancellationException 异常，可以在done()方法中捕获进行处理

		MyCallable<String> callable = new MyCallable();
		MyFutureTask<String> task = new MyFutureTask<>(callable);
		new Thread(task).start();
		String result = task.get();  // 调用get()阻塞当前

	* 不同点：
    	* 1、实现Callable接口的任务线程能返回执行结果；而实现Runnable接口的任务线程不能返回结果
   		* 2、Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛
		* 3、Callable接口支持返回执行结果，此时需要调用FutureTask.get()方法实现，此方法会阻塞当前直到获取结果