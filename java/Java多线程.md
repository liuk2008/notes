## Java多线程 ##

**进程&&线程概念**
	
 	* 进程：进程就是正在运行的程序，是系统进行资源分配和调用的独立单位。每一个进程都有它自己的内存空间和系统资源。
 	* 多进程有什么意义呢?
		* 多进程的作用不是提高执行速度，而是提高CPU的使用率。
 		* 单核计算机：CPU多个进程间进行高效的切换，在任意一个时刻，只能有一个进程运行。

	* 线程： 线程是指进程中的一个执行流程，一个进程可以运行多个线程。线程是程序中单个顺序的控制流，是程序使用CPU的基本单位。
	* 线程是一个操作系统级别的概念。JAVA语言（包括其他编程语言）本身不创建线程；而是调用操作系统层提供的接口创建、控制、销毁线程实例。
	* 多线程有什么意义呢?
 	 	* 多线程的作用不是提高执行速度，而是为了提高应用程序的使用率。 
 	 	* 因为多个线程共享同一个进程的资源(堆内存和方法区)，但是栈内存是独立的，一个线程一个栈。
 	 	* 所以他们仍然是在抢CPU的资源执行。一个时间点上只有能有一个线程执行。

	* 注意：
		* 1、一个进程中的多个线程来说，共享进程的内存块，当有新的线程产生的时候，操作系统不分配新的内存，而是让新线程共享原有的进程块的内存。
		* 因此，线程间的通信很容易，速度也很快。不同的进程因为处于不同的内存块，因此进程之间的通信相对困难。
		* 2、进程主要是针对是在内存管理的虚拟对象，线程主要是针对CPU管理的虚拟对象

	* 进程&线程运行机制：
		* 1、JVM在操作系统中是作为一个进程的，Java所有的线程都运行自这个JVM进程中
		* 2、OS负责将一个进程在不同的CPU上调度到另外一个CPU上，而这个进程，则是由不同的线程构成的，那么说，线程可以在不同的CPU上运行
		* 3、OS将线程作为最小调度单位，进程作为资源分配的最小单位。线程也是由内核来管理的，所以说多线程可以同时运行在多个CPU核上，
		* 但是这也带来一个问题就是，线程切换需要内核的参与。
	
	* JVM运行机制：
		* Java中线程会按优先级分配CPU时间片运行，JVM调度的模式有两种：分时调度和抢占式调度。底层，实际是通过操作系统调度。
			* 1、分时调度 是所有线程轮流获得CPU使用权，并平均分配每个线程占用CPU的时间;
			* 2、抢占式调度 是根据线程的优先级别来获取CPU的使用权。

	* JVM创建线程：底层实际通过不同的操作系统进行创建。实现线程主要有三种方式：使用内核线程实现，使用用户线程实现和使用用户线程加轻量级进程混合实现。
		* 内核线程：直接由操作系统内核支持的线程。由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。
		* 用户线程：由应用进程利用线程库创建和管理，不依赖操作系统的核心，不需要用户态/内核态的切换，速度快，操作系统内核不知道
		* 用户线程加轻量级进程混合实现：

**线程概念**
	
	生命周期：
		* 新建状态：创建一个线程对象，未调用start()方法
		* 可运行状态：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu的使用权 
		* 运行状态：执行线程任务
		* 阻塞状态：阻塞状态是指线程因为某种原因放弃了cpu使用权。三种情况：等待阻塞、同步阻塞、其他阻塞
			* 等待阻塞：调用wait()方法，释放锁，释放CPU执行权，调用notify()方法唤醒线程后，进入到等待队列，然后获取锁，获取CPU执行权
			* 同步阻塞：锁对象
			* 其他阻塞：sleep()方法，释放执行权，不释放锁。必须指定时间
		* 死亡状态：线程任务执行完毕后线程销毁，但是线程对象有可能会存在

	* Java分为两种线程：用户线程和守护线程
	* 当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。

	重点方法：
	* yield():将当前正在执行的线程退让出去，以让就绪队列中的其他线程有更大的几率被cpu调度。即强制自己放弃cpu，并将自己放入就绪队列。
	* join():等待该线程终止。当线程调用start()方法后，调用此方法join()方法，则此线程执行完毕后，后面的线程才能执行 
 	* setDaemon(boolean on):守护线程（后台线程）当前台线程消失后，后台线程也消失，当正在运行的线程都是守护线程时，Java 虚拟机退出。 
 	* ThreadLocal：为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。
 	* 原子性：当存在多个线程时，保证一段代码在任意时刻只有一个线程在执行。AtomicInteger：原子类
 	* volatile

	线程同步：多线程的线程同步机制实际上是靠锁的概念来控制的
	* 1、synchronized作用在于标识一段代码是同步执行，保证代码的原子性，底层通过锁来实现。
	* 2、Java中每个对象都有一个内置锁，也就是监视器锁。某一时刻只能有一个线程拥有该对象的监视器。 
	* 3、当程序运行到synchronized同步方法或代码块时就可以标志一个监视区域，底层会获取相关Java对象的内置锁，此时当前线程会持有对象锁
	* 4、释放锁是指持锁线程退出了synchronized同步方法或代码块。

	多线程间通信方式：
	* 1、共享变量
	* 2、wait/notify机制
	* 3、Lock/Condition机制
	* 4、管道

	多线程处理资源共享问题：
	* 1、使用同步关键字：synchronized，保证了多线程并发时，线程间的互斥行、代码块的原子性、变量的可见性 
		 * 同步方法的锁对象是：this
		 * 静态同步方法的锁对象是：当前类的字节码文件对象。Object.class
		 * 普通块同步，锁是synchronized里面配置的对象 new Object()
	* 2、使用信号量 Semaphore，每次控制一个线程执行
		 * Semaphore semaphore = new Semaphore(1)
		 * semaphore.acquire(); // 获取一把锁
		 * semaphore.release(); // 释放一把锁 
	* 3、使用lock锁，释放锁需放在finally里面 
		 * 1、Lock锁  ReentrantLock（可重入锁）
		 * 2、ReadLock锁
		 * 3、WriteLock锁
	* 4、死锁问题：
		 * 死锁：是指两个或者两个以上的线程在执行的过程中，因争夺资源产生的一种互相等待现象
				public void run() {
					if (flag) {
						synchronized (MyLock.objA) {
							System.out.println("if objA"); // CPU的执行权没有了
							synchronized (MyLock.objB) {
								System.out.println("if objB");
							}
						}
					} else {
						synchronized (MyLock.objB) {
							System.out.println("else objB");
							synchronized (MyLock.objA) {
								System.out.println("else objA");
							}
						}
					}   
				}

	线程中断问题：
	* 1、当对一个线程调用interrupt()方法时
		 * 如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true。被设置中断标志的线程将继续正常运行，不受影响。
		 * 如果线程处于被阻塞状态（sleep, wait, join 等状态），那么线程将立即退出被阻塞状态，并抛出一个InterruptedException
    * 注意：interrupt() 并不能真正的中断线程，需要被调用的线程自己进行配合才行

① 在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程

② 在调用阻塞方法时正确处理InterruptedException异常
	https://blog.csdn.net/qq_38663729/article/details/78232648

**2、生产者消费者问题**

	生产者消费者问题：
	* 1、一个生产者任务，一个消费者任务，一个共享对象，多个线程操作
	* 2、两个线程任务操作中存在多条语句操作共享对象，设置同步代码保证数据
	* 3、通过等待唤醒机制，生产者线程与消费者线程交替运行

    Java中线程协作的最常见的两种方式：

	* 1、Object对象中的wait()、notify()、notifyAll()
		 * notify()：唤醒在此对象监视器上等待的单个线程，如果有多个线程则只能唤醒其中一个
		 * notifyAll()：唤醒在此对象监视器上等待的所有线程
		 * wait():使当前线程主动释放互斥锁，并进入该互斥锁的等待队列。
	* wait(),notify(),notifyAll()都必须使用在同步中，因为要对持有监视器(锁)的线程操作。
	* 由于每个对象都拥有monitor（锁），所以让当前线程等待某个对象的锁，当然应该通过这个对象来操作了。

	* 2、Lock锁，Condition对象中的await()、signal()
		* Condition是个接口，基本的方法就是await()和signal()方法；
		* Condition依赖于Lock接口，生成一个Condition的基本代码是lock.newCondition() 
     	* 调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用
			Conditon中的await()对应Object的wait()
			Condition中的signal()对应Object的notify()
			Condition中的signalAll()对应Object的notifyAll()

	内部机制：
	* 1、调用obj.wait()、notify()前，必须获得obj锁，也就是这两个方法必须写在synchronized(obj) {...} 代码段内。
	* 2、调用obj.wait()后，线程A就释放了obj的锁，否则线程B无法获得obj锁，也就无法在synchronized(obj) {...} 代码段内唤醒A。
	* 3、当obj.wait()方法返回后，线程A需要再次获得obj锁，才能继续执行。
	* 4、如果A1,A2,A3都在obj.wait()，则B调用obj.notify()只能唤醒A1,A2,A3中的一个（具体哪一个由JVM决定）。
	* 5、obj.notifyAll()则能全部唤醒A1,A2,A3，但是要继续执行obj.wait()的下一条语句，必须获得obj锁，因此，A1,A2,A3只有一个有机会获得锁继续执行
 	* 6、当B调用obj.notify()时，B正持有obj锁，A1,A2虽被唤醒但无法获得obj锁。直到B退出synchronized块，释放obj锁后，A1,A2中的一个才有机会获得锁继续执行。
		 	
**3、FutureTask&&Callable**

	* 1、通过实现 Callable 接口，创建线程任务，可以返回任务执行结果。
	* 2、调用 FutureTask 类，传递 Callable 任务，开启工作线程执行任务
		 * Callable：call()运行在工作线程
	* 3、在 FutureTask 类中，线程执行完毕以及取消任务后，done()方法会被调用。
		 * 任务正常结束后，done()运行在工作线程，可以在done()方法中可以调用get()方法获取任务结果
		 * 任务取消后，done()运行在当前线程
	* 4、在当前线程中调用 FutureTask 类的 get() 获取任务执行完毕后的结果，但是会阻塞当前线程
	
	* 注意：
		* 1、可以在done()方法中调用get()获取到任务执行结果，且不会阻塞当前线程
		* 2、调用 FutureTask 类 cancel() 方法后，会抛出 CancellationException 异常，可以在done()方法中捕获进行处理
		* 3、cancel(true) 方法的原理是向正在运行任务的线程发送中断指令，即调用运行任务的 Thread 的 interrupt() 方法。
		*    但是并没有真正结束任务的运行，通过isInterruped()可以设置标记，从而停止任务。
		
	* 不同点：
    	* 1、实现Callable接口的任务线程能返回执行结果；而实现Runnable接口的任务线程不能返回结果
   		* 2、Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛
		* 3、Callable接口支持返回执行结果，此时需要调用FutureTask.get()方法实现，此方法会阻塞当前直到获取结果