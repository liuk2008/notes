## Java多线程 ##

**进程&&线程概念**
	
 	* 进程：进程就是正在运行的程序，是系统进行资源分配和调用的独立单位。每一个进程都有它自己的内存空间和系统资源。
 	* 多进程有什么意义呢?
		* 多进程的作用不是提高执行速度，而是提高CPU的使用率。
 		* 单核计算机：CPU多个进程间进行高效的切换，在任意一个时刻，只能有一个进程运行。

	* 线程： 线程是指进程中的一个执行流程，一个进程可以运行多个线程。线程是程序中单个顺序的控制流，是程序使用CPU的基本单位。
	* 线程是一个操作系统级别的概念。JAVA语言（包括其他编程语言）本身不创建线程；而是调用操作系统层提供的接口创建、控制、销毁线程实例。
	* 多线程有什么意义呢?
 	 	* 多线程的作用不是提高执行速度，而是为了提高应用程序的使用率。 
 	 	* 因为多个线程共享同一个进程的资源(堆内存和方法区)，但是栈内存是独立的，一个线程一个栈。
 	 	* 所以他们仍然是在抢CPU的资源执行。一个时间点上只有能有一个线程执行。

	* 注意：
		* 1、一个进程中的多个线程来说，共享进程的内存块，当有新的线程产生的时候，操作系统不分配新的内存，而是让新线程共享原有的进程块的内存。
		* 因此，线程间的通信很容易，速度也很快。不同的进程因为处于不同的内存块，因此进程之间的通信相对困难。
		* 2、进程主要是针对是在内存管理的虚拟对象，线程主要是针对CPU管理的虚拟对象

	* 进程&线程运行机制：
		* 1、JVM在操作系统中是作为一个进程的，Java所有的线程都运行自这个JVM进程中
		* 2、OS负责将一个进程在不同的CPU上调度到另外一个CPU上，而这个进程，则是由不同的线程构成的，那么说，线程可以在不同的CPU上运行
		* 3、OS将线程作为最小调度单位，进程作为资源分配的最小单位。线程也是由内核来管理的，所以说多线程可以同时运行在多个CPU核上，
		* 但是这也带来一个问题就是，线程切换需要内核的参与。
	
	* JVM运行机制：
		* Java中线程会按优先级分配CPU时间片运行，JVM调度的模式有两种：分时调度和抢占式调度。底层，实际是通过操作系统调度。
			* 1、分时调度 是所有线程轮流获得CPU使用权，并平均分配每个线程占用CPU的时间;
			* 2、抢占式调度 是根据线程的优先级别来获取CPU的使用权。

	* JVM创建线程：底层实际通过不同的操作系统进行创建。实现线程主要有三种方式：使用内核线程实现，使用用户线程实现和使用用户线程加轻量级进程混合实现。
		* 内核线程：直接由操作系统内核支持的线程。由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。
		* 用户线程：由应用进程利用线程库创建和管理，不依赖操作系统的核心，不需要用户态/内核态的切换，速度快，操作系统内核不知道
		* 用户线程加轻量级进程混合实现：

**1、线程概念**
	
	生命周期：
		* 新建状态：创建一个线程对象，未调用start()方法
		* 可运行状态：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu的使用权 
		* 运行状态：执行线程任务
		* 阻塞状态：阻塞状态是指线程因为某种原因放弃了cpu使用权。三种情况：等待阻塞、同步阻塞、其他阻塞
			* 等待阻塞：调用wait()方法，释放锁，释放CPU执行权，调用notify()方法唤醒线程后，进入到等待队列，然后获取锁，获取CPU执行权
			* 同步阻塞：锁对象
			* 其他阻塞：sleep()方法
		* 死亡状态：线程任务执行完毕后线程销毁，但是线程对象有可能会存在

	* Java分为两种线程：用户线程和守护线程
	* 当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。

	重点方法：
	* join(t1):将线程t1合并到当前线程，并等待线程t1执行完毕后才继续执行当前线程。即让t1线程强制插队到当前线程的前面并等待t1完成。
	* yield():将当前正在执行的线程退让出去，以让就绪队列中的其他线程有更大的几率被cpu调度。即强制自己放弃cpu，并将自己放入就绪队列。


**2、FutureTask&&Callable**

	* 1、通过实现 Callable 接口，创建线程任务，可以返回任务执行结果。
	* 2、调用 FutureTask 类，传递 Callable 任务，开启工作线程执行任务
		 * Callable：call()运行在工作线程
	* 3、在 FutureTask 类中，线程执行完毕以及取消任务后，done()方法会被调用。
		 * 任务正常结束后，done()运行在工作线程
		 * 任务取消后，done()运行在当前线程
	* 4、在当前线程中调用 FutureTask 类的 get() 获取任务执行完毕后的结果，但是会阻塞当前线程
	
	* 注意：
		* 1、可以在done()方法中调用get()获取到任务执行结果，且不会阻塞当前线程
		* 2、调用 FutureTask 类 cancel() 方法后，会抛出 CancellationException 异常，可以在done()方法中捕获进行处理
		* 3、cancel(true) 方法的原理是向正在运行任务的线程发送中断指令，即调用运行任务的 Thread 的 interrupt() 方法。
		*    但是并没有真正结束任务的运行，通过isInterruped()可以设置标记，从而停止任务。
		
	* 不同点：
    	* 1、实现Callable接口的任务线程能返回执行结果；而实现Runnable接口的任务线程不能返回结果
   		* 2、Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛
		* 3、Callable接口支持返回执行结果，此时需要调用FutureTask.get()方法实现，此方法会阻塞当前直到获取结果