
	* 为什么用服务而不是线程？
		* 当Android应用程序把所有的界面关闭时进程还没有被销毁，不过处于的是空进程状态，Thread运行在空进程中很容易的被销毁了。
		* 服务不容易被销毁, 如果非法状态下被销毁了, 系统会在内存够用时, 重新启动。

	* adb常用命令
		* 1、查询Activity实例对象：adb shell dumpsys activtiy activities
		* 2、查询keystore信息：keytool -list -v -keystore debug.keystore

	* A界面数据发生改变时通知B界面
		* 1、回调接口
		* 2、发送广播

	* 任务栈相关内容
		1、Android程序打开时会创建一个任务栈，用于存储当前程序的activity，所有的activity属于一个任务栈。
		2、只有在任务栈栈顶的activity才可以跟用户进行交互。
		3、任务栈可以移动到后台并且保留了每一个activity的状态，并且有序的给用户列出它们的任务，而且还不丢失它们状态信息。
		4、退出应用程序时：当把任务栈中所有的activity清除出栈时，任务栈会被销毁，程序退出。
		注意：
		1、每开启一次页面都会在任务栈中添加一个Activity，会造成数据冗余，导致内存溢出的问题
		2、只有任务栈中的Activity全部清除出栈时，任务栈才被销毁，程序才会退出
	
	* Activity的四种启动模式：
		1、standard：
	 	* 默认启动模式，每次创建新的Activity放入任务栈中。
    	2、singleTop：
		* 若不存在Activity实例，则创建新的Activity实例并放入栈顶。	
		* 若存在Activity实例且在栈顶，则复用该实例，若不在栈顶，也会创建新的Activity实例。
	    3、singleTask：
		* 若不存在Activity实例，则创建新的Activity实例并放入栈顶。
        * 若存在Activity实例但是不在栈顶，则复用该实例并让该实例回到栈顶，会清除他上面其他Activity实例，而不会清除栈低存在的其他Activity实例
    	4、singleInstance
        * 在一个新栈中创建该Activity实例，并让多个应用共享该栈中的该Activity实例。
   
  		注意：
	    1、使用Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK标记：
    		* 1、必须同时设置这两个标记，否则没有效果
    		* 2、设置此标记时会清除栈内所有的Activity，并且会新开启一个任务栈重新生成一个Activity实例对象
    	2、启动模式为singleTop或者为singleTask时，重用Activity时会调用onNewIntent方法。
		   需要在onNewIntent()中使用setIntent(intent)赋值给Activity的Intent，否则，后续的getIntent()都是得到老的Intent。

	* 进程优先级
		1、前台进程
		2、可见进程
		3、服务进程
		4、后台进程：
		5、空进程：优先级低，系统会经常终止这种进程

	* Toast的创建需要依赖Handler，存在handler的话，子线程也可以弹出toast
	
	* Intent传递对象时，是将对象拷贝了一份进行传递

	* 内存抖动和内存泄漏
		* 内存抖动：在短时间内有大量的对象被创建或者被回收的现象
		* 内存泄漏：某一段内存在程序里已经不需要了，但是GC回收内存时检测那段内存还是被需要的，不能正常被回收，这种在程序中在没有使用的但是又
		* 不能被回收的内存就是被泄漏的内存。一般检查这段内存是否存在引用和被引用关系，不存在这关系时，就认为可回收，若还存在引用或被引用关系，就认为不可回收。

		* 注意：执行GC操作的时候，任何线程的任何操作都会需要暂停，等待GC操作完成之后，其他操作才能够继续运行（所以垃圾回收运行次数越少，对性能影响就越少）。

	* 分辨率、dp、px、sp相关内容
		* 分辨率：图像在水平和垂直方向上所容纳最大像素个数。例如 960*640 表示表示水平像素数为960个，垂直像素数640个，像素大小为960*640，约60万像素。
		* 注意：在像素大小确定之后，分辨率越高则图像尺寸越小显示效果越好，反之则尺寸越大效果越差。
		* dp：虚拟像素，在不同的像素密度的设备上会自动适配
		* px：像素，1px代表屏幕上一个物理的像素点
		* 屏幕像素密度（density）：每英寸像素数量，dip到px的转换公式: px = dip * density。
		* Android规定，在屏幕像素密度为160dpi的情况下，1dp=1px。而在像素密度为320dpi的情况下，1dp=2px，以此类推。计算公式：1dp=（像素密度/160dpi）*1px。
		* sp同dip/dp相似，会根据用户的字体大小偏好来缩放，专门用于设置字体的大小。
	
	* SharedPreference.Editor的apply和commit方法异同
		* 1、apply没有返回值而commit返回boolean表明修改是否提交成功 
		* 2、apply是将修改数据原子提交到内存, 而后异步真正提交到硬件磁盘, 而commit是同步的提交到硬件磁盘
		* 3、apply方法不会提示任何失败的提示
		* 由于在一个进程中，sharedPreference是单实例，一般不会出现并发冲突，如果对提交的结果不关心的话，建议使用apply
	
	* StickyBroadcast广播
		* 1、普通广播：这种广播可以依次传递给各个处理器去处理
		* 2、有序广播：这种广播在处理器端的处理顺序是按照处理器的不同优先级来区分的，高优先级的处理器会优先截获这个消息，并且可以将这个消息删除
		* 3、粘性广播：粘性消息在发送后就一直存在于系统的消息容器里面，等待对应的处理器去处理，如果暂时没有处理器处理这个消息则一直在消息容器里面处于等待状态，
		* 粘性广播的Receiver如果被销毁，那么下次重建时会自动接收到消息数据。
		* 注意：
		* 1、普通广播和粘性消息不同被截获，而有序广播是可以被截获的。
		* 2、粘性广播调用registerReceiver能马上接受广播，而普通广播不行。
		* 3、粘性广播，是指广播接收器一注册马上就能接收到广播的一种机制，当然首先系统要存在广播。而普通广播就是要先注册广播接收器，然后广播被发送到系统，
		* 广播接收器才能接收到广播。

	* 增量更新、热修复、插件化
		* 增量更新：通过生成差分包的供下载，再合并达到更新的方式
		* 热修复（热更新）：强调的是修改线上版本的bug，用技术去实现不更新整个apk的条件下，修改掉bug。

	* 常见异步机制
		* Thread+Handler
		* 常用第三方网络框架
		* AsyncTask
		* Executor线程池
		* IntentService机制
		* HandlerThread机制
		* AsyncQueryHandler

	* 常见内存泄漏
		* Handler未处理
		* 内部类引用外部类对象
		* 单例模式
		* 线程任务
		* 资源未关闭
		* Android组件未关闭








